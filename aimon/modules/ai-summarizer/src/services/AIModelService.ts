import OpenAI from 'openai';
import { AIModelConfig, SummaryTemplate } from '../types';
import { logger } from '../utils/logger';

export class AIModelService {
  private openai: OpenAI | null = null;
  private config: AIModelConfig;
  private usageStats = {
    totalRequests: 0,
    totalTokens: 0,
    averageResponseTime: 0
  };

  constructor(config: AIModelConfig) {
    this.config = config;
    this.initializeProvider();
  }

  private initializeProvider(): void {
    switch (this.config.provider) {
      case 'openai':
        this.openai = new OpenAI({
          apiKey: this.config.api_key,
          baseURL: this.config.base_url
        });
        break;
      
      case 'anthropic':
        // Would initialize Anthropic client
        logger.warn('Anthropic provider not yet implemented, falling back to OpenAI');
        this.openai = new OpenAI({
          apiKey: this.config.api_key,
          baseURL: this.config.base_url
        });
        break;
      
      case 'local':
        // Would initialize local model client
        logger.warn('Local provider not yet implemented, falling back to OpenAI');
        this.openai = new OpenAI({
          apiKey: this.config.api_key || 'dummy',
          baseURL: this.config.base_url || 'http://localhost:8080'
        });
        break;
    }
  }

  async generateSummary(prompt: string, template: SummaryTemplate): Promise<string> {
    if (!this.openai) {
      throw new Error('AI provider not initialized');
    }

    const startTime = Date.now();

    try {
      logger.debug('Generating summary with AI model');

      const messages = [
        {
          role: 'system' as const,
          content: this.buildSystemPrompt(template)
        },
        {
          role: 'user' as const,
          content: prompt
        }
      ];

      const response = await this.openai.chat.completions.create({
        model: this.config.model,
        messages,
        temperature: this.config.temperature,
        max_tokens: Math.min(this.config.max_tokens, template.max_length),
        timeout: this.config.timeout
      });

      const content = response.choices[0]?.message?.content;
      if (!content) {
        throw new Error('No content generated by AI model');
      }

      // Update usage stats
      const responseTime = Date.now() - startTime;
      this.updateUsageStats(responseTime, response.usage?.total_tokens || 0);

      logger.info(`Generated summary in ${responseTime}ms`);
      return content;

    } catch (error) {
      logger.error('Failed to generate summary with AI:', error);
      
      // Fallback to template-based summary
      return this.generateFallbackSummary(prompt, template);
    }
  }

  private buildSystemPrompt(template: SummaryTemplate): string {
    let systemPrompt = `You are an AI assistant specialized in creating work activity summaries. 
Your task is to analyze user activity data and create ${template.output_format} summaries.

Guidelines:
- Focus on productivity and meaningful work patterns
- Be concise but informative
- Highlight achievements and areas for improvement
- Use a professional but friendly tone
- Target audience: ${template.target_audience}`;

    if (template.output_format === 'bullet_points') {
      systemPrompt += '\n- Format your response as clear bullet points';
    } else if (template.output_format === 'narrative') {
      systemPrompt += '\n- Write in a flowing narrative style';
    } else if (template.output_format === 'structured') {
      systemPrompt += '\n- Use clear sections with headers';
    }

    systemPrompt += `\n- Keep response under ${template.max_length} characters`;

    return systemPrompt;
  }

  private generateFallbackSummary(prompt: string, template: SummaryTemplate): string {
    // Extract basic information from prompt for fallback
    const timeMatch = prompt.match(/(\d+) activities/);
    const productivityMatch = prompt.match(/Productivity score: ([\d.]+)/);
    const activeTimeMatch = prompt.match(/Active time: ([\dhm\s]+)/);

    const activities = timeMatch ? timeMatch[1] : 'several';
    const productivity = productivityMatch ? productivityMatch[1] : 'unknown';
    const activeTime = activeTimeMatch ? activeTimeMatch[1] : 'some time';

    return `Work Summary:

During this period, you completed ${activities} activities with a productivity score of ${productivity}%. 
You were actively working for ${activeTime}.

Key activities included various productive tasks across different applications. 
Continue maintaining focus on your primary work activities to improve overall productivity.

This summary was generated using fallback mode due to AI service unavailability.`;
  }

  async testConnection(): Promise<boolean> {
    try {
      if (!this.openai) return false;

      const response = await this.openai.chat.completions.create({
        model: this.config.model,
        messages: [{ role: 'user', content: 'Hello' }],
        max_tokens: 5,
        timeout: 5000
      });

      return !!response.choices[0]?.message?.content;
    } catch (error) {
      logger.error('AI model connection test failed:', error);
      return false;
    }
  }

  private updateUsageStats(responseTime: number, tokens: number): void {
    this.usageStats.totalRequests++;
    this.usageStats.totalTokens += tokens;
    
    // Calculate running average
    const previousAvg = this.usageStats.averageResponseTime;
    this.usageStats.averageResponseTime = 
      (previousAvg * (this.usageStats.totalRequests - 1) + responseTime) / this.usageStats.totalRequests;
  }

  getUsageStats(): typeof this.usageStats {
    return { ...this.usageStats };
  }

  updateConfig(config: Partial<AIModelConfig>): void {
    this.config = { ...this.config, ...config };
    this.initializeProvider();
  }

  async estimateTokens(text: string): Promise<number> {
    // Simple estimation - in production would use tiktoken
    return Math.ceil(text.length / 4);
  }

  async validateModel(): Promise<{ valid: boolean; error?: string }> {
    try {
      const isConnected = await this.testConnection();
      return { valid: isConnected };
    } catch (error) {
      return { 
        valid: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }
}